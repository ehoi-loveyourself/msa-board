# msa-board
[인프런] 스프링부트로 직접 만들면서 배우는 대규모 시스템 설계

1. Primary Key 생성 전략 (총 4가지) 
   
   1) DB auto_increment
      
        - 분산 데이터베이스 환경에서 PK가 중복될 수 있기 때문에 식별자의 유일성이 보장되지 않는다. (여러 사드에서 동일한 PK를 가지는 상황)
        - 클라이언트 측에 노출하면 보안 문제가 발생
          
            데이터 개수 또는 특정 시점의 식별자를 예측: 방금 가잆햇더니 user_id가 1000이면? 현재 1000명의 사용자가 있다는 사실을 유추할 수 있음
        - 간단하기 때문에 다음 상황에서 유리하다.
          
            - 보안적인 문제를 크게 고려하지 않는 상황
            - 단일 DB를 사용하거나 애플리케이션에서 직접 PK 중복을 구분하는 상황
        - 보안적인 문제만 염려되는 것이라면,
        
            PK는 데이터베이스의 식별자로만 사용하고, 애플리케이션에서의 식별자를 위해 별도 유니크 인덱스를 사용할 수도 있다. 
            하지만, 별도의 식별자를 사용하면 Secondary Index로 포인터를 찾은 후, Clustered Index로 데이터에 접근하므로, 조회 비용이 증가한다는 단점이 있다.
   2) 유니크 문자열 또는 숫자
      
        - UUID나 난수를 생성하여 PK를 지정할 수 있다.
          - 정렬 데이터가 아니라 랜덤 데이터를 삽입하는 것이다.
          - 키 생성 방식이 간단하다.
        - 랜덤 데이터로 인한 성능 저하가 발생할 수 있다는 단점이 있다.
          - Clustered Index는 정렬된 상태를 유지한다.
          - 데이터를 삽입할 때 필요한 인덱스 페이지가 가득 찼다면, B+ tree 재구성 및 페이지 분할로 디스크 I/O가 증가한다.
          - PK를 이용한 범위 조회가 필요하다면, 디스크에서 랜덤 I/O가 발생하기 때문에 순차 I/O보다 성능이 저하된다.
   3) 유니크 정렬 문자열
      - 장점
        - 분산 환경에 대한 PK 중복 문제 해결
        - 보안 문제 해결
        - 랜덤 데이터에 의한 성능 문제 해결
      - UUID v7, ULID 등의 알고리즘
        - 일반적으로 알려진 알고리즘은 128비트를 사용한다.
      - 데이터 크기에 따라, 공간 및 성능 효율이 달라진다.
        - Clustered Index는 PK를 기준으로 만들어진다.
        - Secondary Index는 데이터에 접근할 수 있는 포인터를 가진다.
          - 즉, PK를 가지고 있다.
        - PK가 크면 클수록
          - 데이터는 더 많은 공간을 차지하고 비교 연산에 의한 정렬/조회에 더 많은 비용을 소모한다.
   4) 유니크 정렬 숫자
       - 장점
           - 분산 환경에 대한 PK 중복 문제 해결
           - 보안 문제 해결
           - 랜덤 데이터에 의한 성능 문제 해결
       - Snowflake, TSID 등의 알고리즘
         - 64비트를 사용한다. (BIGINT) -> 앞서 살펴본 문자열 방식보다 적은 공간을 사용한다.
         - 정렬을 위해 타임스탬프를 나타내는 비트 수의 제한으로, 키 생성을 위한 시간적인 한계가 있을 수 있다. 문자열 알고리즘에서도 동일한 문제가 있지만 비트 수가 많을수록 제한이 덜할 수 있긴 하다.
    
    결론: 각 특성을 이해하고 적절히 선택할 것


2. 유틸성 클래스의 규칙
    1) `private` 생성자로 인스턴스 생성자 막기!
   2) `static` 메서드만 사용해서 상태없이 기능만 제공하기
   3) `final` 또는 `abstract` 로 클래스를 선언하여 상속 방지 (선택사항)